class ResNetMultiChannel(nn.Module):
    def __init__(self, n_channels=16, embedding_dim=256):
        super().__init__()
        weights = ResNet50_Weights.IMAGENET1K_V2
        resnet = resnet50(weights=weights)
        resnet.conv1 = nn.Conv2d(n_channels, 64, kernel_size=7, stride=2, padding=3, bias=False)
        with torch.no_grad():
            if n_channels == 3:
                resnet.conv1.weight.copy_(resnet50(weights=weights).conv1.weight)
            else:
                w = resnet50(weights=weights).conv1.weight
                mean_weight = w.mean(dim=1, keepdim=True)
                resnet.conv1.weight.copy_(mean_weight.repeat(1, n_channels, 1, 1))
        self.resnet = resnet
        self.project = nn.Linear(resnet.fc.in_features, embedding_dim)
        self.resnet.fc = nn.Identity()

    def forward(self, x):
        feats = self.resnet(x)
        return self.project(feats)


class RNAEncoder(nn.Module):
    def __init__(self, input_dim, embedding_dim=256):
        super().__init__()

        if input_dim >= 128:
            self.model = nn.Sequential(
                nn.Linear(input_dim, 128),
                nn.ReLU(),
                nn.Linear(128, 64),
                nn.ReLU(),
                nn.Linear(64, embedding_dim)
            )
        elif input_dim >= 64:
            self.model = nn.Sequential(
                nn.Linear(input_dim, 64),
                nn.ReLU(),
                nn.Linear(64, embedding_dim)
            )
        else:
            self.model = nn.Sequential(
                nn.Linear(input_dim, 32),
                nn.ReLU(),
                nn.Linear(32, embedding_dim)
            )

    def forward(self, x):
        return self.model(x)

class CLIPModel(nn.Module):
    def __init__(self, rna_encoder, image_encoder):
        super().__init__()
        self.rna_encoder = rna_encoder
        self.image_encoder = image_encoder

    def forward(self, rna_input, image_input):
        rna_embeddings = self.rna_encoder(rna_input)
        image_embeddings = self.image_encoder(image_input)
        return rna_embeddings, image_embeddings



class ContrastiveLoss(nn.Module):
    def __init__(self, temperature=0.5):
        super().__init__()
        self.temperature = temperature

    def forward(self, rna_embeddings, image_embeddings):
        rna_embeddings = F.normalize(rna_embeddings, p=2, dim=-1)
        image_embeddings = F.normalize(image_embeddings, p=2, dim=-1)
        similarity_matrix = torch.matmul(rna_embeddings, image_embeddings.T) / self.temperature
        labels = torch.arange(rna_embeddings.size(0)).to(rna_embeddings.device)
        loss_fn = nn.CrossEntropyLoss()
        loss = (loss_fn(similarity_matrix, labels) + loss_fn(similarity_matrix.T, labels)) / 2
        return loss
